from Crypto.Util.number import *
import Crypto.Hash
from Crypto.Hash import SHA256
import random
import os
from numpy import *
import binascii
from Crypto.PublicKey import RSA, ECC
from Crypto.Cipher import PKCS1_OAEP, AES
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme
# from tinyec import registry
import secrets
import json
import re
import hashlib
from operator import mul
from time import sleep
from base64 import b64encode, b64decode
from itertools import cycle
import textwrap
#####################################################################################################################
# Name:        DHExample()
# Description: Goes through the steps of Alice and Bob setting their public and private key and setting up a shared secret
# Usage:       
# Author:
# Date: 
######################################################################################################################
def DHKEexample():
    #ALICE hat
    print("Alice:")
    p = getStrongPrime(512)
    print("Strong Prime p=\n", p)
    a = getRandomRange(2, p-2)
    while GCD(a, p-1) != 1:
        a = getRandomRange(2, p-2)
    print("Alice's private key a=\n", a)
    # print(GCD(a, p-1))
    base = 2
    print("Alice's base g=", base)
    #calculate g^a mod(p)
    A = pow(base, a, p)
    print("Alice's public key A\n", A)
    public_triplet = (p, base, A)

    #BOB hat
    print("Bob:")
    b = getRandomRange(2, p-2)
    while GCD(b, p-1) != 1:
        b = getRandomRange(2, p-2)
    #print(GCD(b, p-1))
    print("Bob's private key b=\n", b)
    #calculate g^b mod(p)
    B = pow(base, b, p)
    print("Bob's public key B\n", B)
    #calculate A^b mod(p)
    BobsK = pow(A, b, p)
    #base^(ab)
    print("Bob's sercet from Alice's public key:\n", BobsK)

    #Alice hat
    #calculate B^a mod(p)
    AlicesK = pow(B, a, p)
    print("Alice's sercet from Bob's public key:\n", AlicesK)
    print("Do Alice and Bob share the secret? ", AlicesK == BobsK)
    #public stuff was (base, p, A, B)
    #private stuff was (a, b, K)

#####################################################################################################################
# Name:        DHgenkeys()
# Description: Returns a DH private/public key pair based the given parameters
# Usage:       b, B = genpublickey(p, g)
# Author:
# Date: 
######################################################################################################################
def DHgenkeys(p, g):
    prvtk = getRandomRange(2, p-2)
    while GCD(prvtk, p-1) != 1:
        prvtk = getRandomRange(2, p-2)
    pblck = pow(g, prvtk, p)
    return prvtk, pblck
#####################################################################################################################
# Name:        DHgensecret()
# Description: Returns a DH secret based the given parameters generated by Bob, where A is Alice's public key
#              b is Bob's private key and p is the shared prime number. Returns A^b mod(p).
# Usage:       B = genpublickey(A, b, p)
# Author:
# Date: 
######################################################################################################################
def DHgensecret(A, b, p):
    return pow(A, b, p)

####################################################################################
# Python program to demonstrate working of extended
# Euclidean Algorithm
# Geeks for Geeks    
# function for extended Euclidean Algorithm
####################################################################################
def gcdExtended(a, b):
    # Base Case
    if a == 0 :
        return b,0,1 
    gcd,x1,y1 = gcdExtended(b%a, a)
    # Update x and y using results of recursive
    # call
    x = y1 - (b//a) * x1
    y = x1
     
    return gcd,x,y
#####################################################################################################################
# Name:        Kinv()
# Description: calculates K inverse, example from classs Module 5 Lesson 2 part 1
# Usage:       B = genpublickey(A, b, p)
# Author:
# Date: 
######################################################################################################################
def Kinv():
    base, p, A, b, B, K = (2, 10687697916839423481635652118834007146946191294923255999661800948347650137507026580619063362540990142707750877588667878612127060085500161314697355403684817, 2928243870826960095527291341465041733378889438215298802243486942058641990714876730583731143393190263600568508345339395159154963799337791343494391943691343, 3145210314820064242923507206669481373441142139974754058098783378176549671945497998282927729775598688573873767902141750162553709308511659052840059727418475, 243091867572058234977747830694512875533111671243488638254559652058902886471446388452939490802580633118475567282374030327794613305260510150217941576250986, 10641194206677418802665706883329799029279202711791423315137652972422041285490884720641376996879901644227818499713135456300204394885953287489010786875194858)
    kinv_01 = pow(K,p-2,p)
    print("k = ", K)
    print("K inverse_01 = ", kinv_01)
    print("K*kinverse_01 mod(p) = ", (K*kinv_01)%p)
    kinv_02, x,y = gcdExtended(p,K)
    print("K inverse_02 = ", kinv_02)
    print("K*kinverse_02 x*p + y*K = ", (x*p + y*K))
    kinv_03 = pow(A, (p -1 -b),p)
    print("K inversfe_03 = ", kinv_03)
    print("K*kinverse_03 mod(p) = ", (K*kinv_03)%p)

#####################################################################################################################
# Name: safe_prim()
# Author: Prof. Andy Novocin, University of Delaware 
#
######################################################################################################################
def safe_prime(bits):
    found_safe_prime = False
    ohshit = 0
    while (not found_safe_prime and ohshit < 1000000):
        ohshit += 1
        q = 2*random.randint(2**(bits-1), 2**(bits))-1
        if random.power_mod(2,2*q, 2*q + 1) != 1:
            continue
        if not q.is_prime(False):
            continue
        found_safe_prime = True
    if ohshit >= 1000000:
        return -1
    return 2*q+1
#####################################################################################################################
# Name:         elgamalencrypt()
# Descritpion:  Calculate the El Gamal Encryption of a plain text message m, and a shared secret K 
# Usage:        ciphertext = elgamalencrypt(m,K, p)
# Input:        m, type str is the messge to be encrypted; K long the DH secret; p, type Long the shared prime
#               used to compute the keys between the users
# Author:       Rico Leone
# Date:         March 19, 2023
#####################################################################################################################
def elgamalencrypt(m, K, p):
    base = 16
    msg = int(binascii.hexlify(m.encode()), base)
    return (msg * K)% p
#####################################################################################################################
# Name:         elgamaldecrypt()
# Descritpion:  Calculate the El Gamal Encryption of a plain text message m, and a shared secret K 
# Usage:        plaintext = elgamalencrypt(m,K, p)
# Input:        c, type str cyphertext; K, type Long, the DH secret; p, type Long the shared prime
#               used to compute the keys between the users 
# Author:       Rico Leone
# Date:         March 19, 2023
#####################################################################################################################
def elgamaldecrypt(c, K, p):
    msg = (c*pow(K,p-2,p)) % p
    return long_to_bytes(msg).decode()
#####################################################################################################################
# Name:         elgamalencrytionTest()
# Descritpion:  Demonstration of the El Gamal message sharing process
# Usage:        elgamalencrypttionTest(m,g, p)
# Input:        m, type str is the messge to be encrypted; g is the generator; p, type Long the shared prime
#               used to compute the keys between the users
#
# Author:       Rico Leone
# Date:         March 19, 2023
#####################################################################################################################
def elgamalencryptionTest(m, g, p):
    #ALICE hat
    print("Alice:")
    # p = getStrongPrime(512)
    # print("Strong Prime p=\n", p)
    a = getRandomRange(2, p-2)
    while GCD(a, p-1) != 1:
        a = getRandomRange(2, p-2)
    print("Alice's private key a=\n", a)
    # print(GCD(a, p-1))
    base = g
    print("Alice's base g=", base)
    #calculate g^a mod(p)
    A = pow(base, a, p)
    print("Alice's public key A\n", A)
    public_triplet = (p, base, A)

    #BOB
    print("Bob:")
    b = getRandomRange(2, p-2)
    while GCD(b, p-1) != 1:
        b = getRandomRange(2, p-2)
    #print(GCD(b, p-1))
    print("Bob's private key b=\n", b)
    #calculate g^b mod(p)
    B = pow(base, b, p)
    print("Bob's public key B\n", B)
    #calculate A^b mod(p)
    BobsK = pow(A, b, p)
    #base^(ab)
    print("Bob's sercet from Alice's public key:\n", BobsK)

    #Alice hat
    #calculate B^a mod(p)
    AlicesK = pow(B, a, p)
    print("Alice's sercet from Bob's public key:\n", AlicesK)
    print("Do Alice and Bob share the secret? ", AlicesK == BobsK)

    print("Alice's message = \n", m)
    ct = elgamalencrypt(m, AlicesK, p)
    print("Alice's ciphertext = \n", ct)
    pt =  elgamaldecrypt(ct, BobsK, p)
    print("Bob's decrypted message =\n",pt)

    if pt == m:
        print("THE TEST PASSED!!")

    #public stuff was (base, p, A, B)
    #private stuff was (a, b, K)
#####################################################################################################################
# Name:         elgamalattac()
# Descritpion:  Demonstration of the El Gamal message sharing process
# Usage:        elgamalencrypttionTest(m,g, p)
# Input:        none
#
# Author:       Rico Leone
# Date:         March 19, 2023
#####################################################################################################################
def elgamalattack():
    p = 163670078465634157857519802545138935809010199145511170900426792066810118692890853756328328904060103299236705660085843733701482650706147356046250160936734614961943086896967709516991970437908723631358421432712887964231613968225392610707657739744421494449450006804081827609247649038487571872041380516056837395459
    g = 2
    c1 = 18424891061981125566079466891923819180189054061023814911996244968757009636277781996991198589205553366877632626019687233233562516536979650853205499214249094240900255342184044396745719365913308597675593979310737613720122429835760055805218845303574586686599271581737663333099357124617446774817423136689946166367
    c2 = 147916986843316695573527469896022062497486746186799547986333428947128110557487364196308461373471989565404856104071324637254647685467504146965165326708794537673201648748801360926219432677374843811543425663953769549430785910736947688203941658591437841781348072102214897713002887676885484302975358896835374731746
    m1 = 'andy love simone'
    
    #compute K = m1 inverse * c1 mod p
    m1_int = int(m1.encode().hex(), 16)
    m1_inv = pow(m1_int,p-2,p)
    K = (m1_inv * c1) % p

    #compute m2 = c2*Kinver (modp)
    K_inv = pow(K,p-2,p)
    m2 = (K_inv * c2) % p
    print("m2 = ", long_to_bytes(m2).decode())
#####################################################################################################################
# Name:        aliceandbob()
# Descritpion: Shows all the parts to complete a secure connection
# Usage:
# Author: Rico Leone
# Date:   March 19, 2023
#####################################################################################################################
def aliceandbob():
    #ALICE hat
    print("Alice:")
    p = getStrongPrime(512)
    print("Strong Prime p=\n", p)
    a = getRandomRange(2, p-2)
    while GCD(a, p-1) != 1:
        a = getRandomRange(2, p-2)
    print("Alice's private key a=\n", a)
    # print(GCD(a, p-1))
    base = 2
    print("Alice's base g=", base)
    #calculate g^a mod(p)
    A = pow(base, a, p)
    print("Alice's public key A\n", A)
    public_triplet = (p, base, A)

    #BOB hat
    print("Bob:")
    b = getRandomRange(2, p-2)
    while GCD(b, p-1) != 1:
        b = getRandomRange(2, p-2)
    #print(GCD(b, p-1))
    print("Bob's private key b=\n", b)
    #calculate g^b mod(p)
    B = pow(base, b, p)
    print("Bob's public key B\n", B)
    #calculate A^b mod(p)
    BobsK = pow(A, b, p)
    #base^(ab)
    print("Bob's sercet from Alice's public key:\n", BobsK)

    #Alice hat
    #calculate B^a mod(p)
    AlicesK = pow(B, a, p)
    print("Alice's sercet from Bob's public key:\n", AlicesK)
    print("Do Alice and Bob share the secret? ", AlicesK == BobsK)
    #public stuff was (base, p, A, B)
    #private stuff was (a, b, K)
    ####################################################################################################################
    #
    #
    ####################################################################################################################
def hasPrimeFactor(n):
    if n & 1 == 0:
        return True
    d= 3
    while d * d <= n:
        if n % d == 0:
            return True
        d= d + 2
    return False

#####################################################################################################################
# Name:         RSA_encrypt_decrypt()
# Descritpion:  Generates an RSA public/private key pair then prompts the user for input text, which it then encrypts
#               and decrypts the messages, printing in on the screen for the user to verify.The pattern used by the 
#               RSA is similar to the AES pattern from the Crypto library.
# Usage:
# Author: Rico Leone
# Date:   March 19, 2023
#####################################################################################################################
def RSA_encrypt_decrypt():

    key = RSA.generate(2048)
    private_key = key.export_key('PEM')
    public_key = key.publickey().exportKey('PEM')
    message = input('plain text for RSA encryption and decryption:')

    message = str.encode(message)
    rsa_public_key = RSA.importKey(public_key)
    rsa_public_key = PKCS1_OAEP.new(rsa_public_key)
    encrypted_text = rsa_public_key.encrypt(message)
    print('your encrypted_text is : {}'.format(encrypted_text))
    rsa_private_key = RSA.importKey(private_key)
    rsa_private_key = PKCS1_OAEP.new(rsa_private_key)
    decrypted_text = rsa_private_key.decrypt(encrypted_text)
    print('your decrypted_text is : {}'.format(decrypted_text.decode()))
#####################################################################################################################
# Name:         RSA_encrypt_decrypt()
# Descritpion:  Generates an RSA public/private key pair then prompts the user for input text, which it then encrypts
#               and decrypts the messages, printing in on the screen for the user to verify.The pattern used by the 
#               RSA is similar to the AES pattern from the Crypto library.
# Usage:
# Author: Rico Leone
# Date:   March 19, 2023
#####################################################################################################################
def gen_RSA_keys():
    key = RSA.generate(2048)
    private_key = key.export_key('PEM')
    public_key = key.publickey().exportKey('PEM')
    return private_key, public_key
#####################################################################################################################
# Name:         RSA_encrypt_decrypt()
# Descritpion:  Generates an RSA public/private key pair then prompts the user for input text, which it then encrypts
#               and decrypts the messages, printing in on the screen for the user to verify.The pattern used by the 
#               RSA is similar to the AES pattern from the Crypto library.
# Usage:
# Author: Rico Leone
# Date:   March 19, 2023
#####################################################################################################################
def RSA_encrypt(message, public_key):
    message = str.encode(message)
    rsa_public_key = RSA.importKey(public_key)
    rsa_public_key = PKCS1_OAEP.new(rsa_public_key)
    ct = rsa_public_key.encrypt(message)
    print("ct = ",ct)
    return ct
#####################################################################################################################
# Name:         RSA_encrypt_decrypt()
# Descritpion:  Generates an RSA public/private key pair then prompts the user for input text, which it then encrypts
#               and decrypts the messages, printing in on the screen for the user to verify.The pattern used by the 
#               RSA is similar to the AES pattern from the Crypto library.
# Usage:
# Author: Rico Leone
# Date:   March 19, 2023
#####################################################################################################################
def RSA_decrypt(ct, private_key):
    rsa_private_key = RSA.importKey(private_key)
    rsa_private_key = PKCS1_OAEP.new(rsa_private_key)
    pt = rsa_private_key.decrypt(ct)
    print("pt = ", pt.decode())
####################################################################################################################
# Name:     RSAexample
# ##################################################################################################################
def RSAexample(filename = "rsa_key.json"):
    with open(filename, 'r') as json_file:
        rsa = json.load(json_file)
    n = int(rsa['n'])
    e = int(rsa['e'])
    d = int(rsa['d'])
    p = int(rsa['p'])
    q = int(rsa['q'])
    print("n = ", n)
    print("e = ", e)
    print("d = ", d)
    print("p = ", p)
    print("q = ", q)
    m = int('andy is great\n'.encode().hex(), 16)
    C = pow(m,d,n)
    M = pow(C,e,n)
    print("M = ", long_to_bytes(M).decode())
    if M == m:
        print("RSA TEST PASSED!")
####################################################################################################################
# Name:     RSA_sign_keypair
###################################################################################################################
def gen_RSA_sign_keys():
    key_pair = RSA.generate(2048)
    public_key = key_pair.publickey()
    return key_pair, public_key
####################################################################################################################
# Name:     RSA_sign
#
###################################################################################################################
def RSA_sign(msg, keypair):
    hashval = b''
    if type(msg) == bytes:
        hashval = SHA256.new(msg)
    else:
        hashval = SHA256.new(msg.encode())
    signer = PKCS115_SigScheme(keypair)
    signature = signer.sign(hashval)
    # print("\n Signature Raw:", signature)
    # print("\n Signature:", binascii.hexlify(signature))
    return signature
####################################################################################################################
# Name:     RSA_verify
###################################################################################################################
def RSA_verify(msg, signature, pubkey):
    valid = False
    hashval = b''
    if type(msg) == type(hashval):
        hashval = SHA256.new(msg)
    else:
        hashval = SHA256.new(msg.encode())
    verifier = PKCS115_SigScheme(pubkey)
    try:
        verifier.verify(hashval, signature)
        # print("Signature is valid.")
        valid = True
    except:
        # print("Signature is NOT valid.")
        valid = False
    return valid
####################################################################################################################
# Name:     RSAexample
########################################################################################
def get_or_create_public_key(filename: str = "private_key.pem"):
    """ Helper function to retrieve public key """
    # private_key_file = os.path.join(ECC.settings.BASE_DIR, filename)
    if True:
    # if os.path.exists(private_key_file):
        file = open(filename, "rt")
        private_key = ECC.import_key(file.read())
    else:
        private_key = ECC.generate(curve="P-256")
        file = open(private_key_file, "wt")
        file.write(
            private_key.export_key(
                format="PEM",
                use_pkcs8=True,
                passphrase=ECC.settings.SECRET_KEY,
                protection="PBKDF2WithHMAC-SHA1AndAES128-CBC",
            )
        )
    file.close()
    public_key = private_key.public_key()
    return public_key.export_key(format="PEM")
#######################################################################################
# Name: add_points
#
#
#
######################################################################################
def add_points(x1,y1,x2,y2,p,a,b):
    s = 0
    # kinv_02, x,y = gcdExtended(p,K)
    if x1 == x2 and y1 == y2:
        inv, x,y = gcdExtended(p, (2*y1))
        s = ((3*x1**2 + a) * inv) % p
        #s = ((3*x1**2 + a) * (2*y1).inverse_mod(p)) % p
    else:
        inv, x,y = gcdExtended(p, (x2-x1))
        s = ((y2 - y1) * inv) % p
        # s = ((y2 - y1) * (x2 - x1).inverse_mod(p)) % p
    x3 = (s**2 - x1 - x2) % p
    y3 = (s*(x1-x3) -y1) % p
    return x3, y3
#######################################################################################
# Name:     Param_readerEC()
# Description:
# Author:   Prof. Andy Novocin, University of Delaware
# 
# #####################################################################################       
def param_readerEC():
    f=open('parameters_EC','r')
    lines=f.readlines()
    f.close()
    params = {}
    currentHex=''
    currentParam=''

    def h2i(hexLines):
        if (hexLines == ''):
            return 0
        return int(hexLines.replace(' ','').replace(':',''), 16)

    def splitPoint(hexLines):
        gen=hexLines.replace(' ','').replace(':','')[2:]
        gl=len(gen)
        return (int(gen[:int(gl/2)],16), int(gen[int(gl/2):], 16))

    ecpoints=["Gener", "pub"]

    for line in lines:
        if line[0].isalpha():
            if (currentHex != '' and currentParam != ''):
                print("key:",currentParam)
                if not currentParam in ecpoints:
                    params[currentParam]=h2i(currentHex)
                else:
                    params[currentParam]=splitPoint(currentHex)
            currentParam = line.strip().replace(':','')[:5]
            currentHex=''
        else:
            currentHex+=line.strip()
    print(params)    

######################################################################################
# Name:     Param_readerRSA()
# Description:
# Author:   Prof. Andy Novocin, University of Delaware
# 
# #####################################################################################       
def param_readerRSA():
    f=open('parameters_rsa','r')
    lines=f.readlines()
    f.close()
    params = {}
    currentHex=''
    currentParam=''

    def h2i(hexLines):
        if (hexLines == ''):
            return 0
        return int(hexLines.replace(' ','').replace(':',''), 16)

    def splitPoint(hexLines):
        gen=hexLines.replace(' ','').replace(':','')[2:]
        gl=len(gen)
        return (int(gen[:int(gl/2)],16), int(gen[int(gl/2):], 16))

    ecpoints=["Gener", "pub"]

    for line in lines:
        if line[0].isalpha():
            if (currentHex != '' and currentParam != ''):
                print("key:",currentParam)
                if not currentParam in ecpoints:
                    params[currentParam]=h2i(currentHex)
                else:
                    params[currentParam]=splitPoint(currentHex)
            currentParam = line.strip().replace(':','')
            currentHex=''
        else:
            currentHex+=line.strip()
    print(params)
#####################################################################################
# Name:     Param_readerRSA()
# Description:
# Author:   Prof. Andy Novocin, University of Delaware
# 
# #####################################################################################    
def Param_readerDSA_private():
    f= open('private_parameters_dsa','r')
    lngstr=f.read()
    f.close()
    lines = lngstr.split('\n')

    params = {}
    nextkey=''
    morehex=''
    for i in range(len(lines)):
        output = re.findall('^\s*([^:]*?):\s*$', lines[i])
        if len(output) == 1:
            if nextkey != '' and morehex != '':
                params[nextkey] = int(morehex.replace(':',''), 16)
            nextkey = output[0]
            morehex = ''
        else:
            output = re.findall('^\s*(.*?)\s*$', lines[i])
            if len(output) == 1:
                morehex += output[0]
    if nextkey != '' and morehex != '':
        params[nextkey] = int(morehex.replace(':',''), 16)
    print(params)
################################################################################################################################
# Name:         validate_DSAParams()
# Description:  performs test on DSAParameters
# Author:   
# 
# ###############################################################################################################################
def validate_DSAParams():
    # how to generate DSA parameters
    # openssl dsaparam 1024 > dsaparam.pem
    # openssl dsaparam -in dsaparam.pem -text -noout > parameters_dsa
    # openssl gendsa -out dsa_priv.pem dsaparam.pem
    # openssl dsa -in dsa_priv.pem -noout -text > private_parameters
    # mv private_parameters private_parameters_dsa
    P = 133816104091371373992625953481859061445353114771014596914261111122761021761778631865242856578868998171720224167087168871531457596932320994261406831331814245335973803811715133507093504470933991842351435835414313732735067339039825541694096290393783468672924917519595132080054031077617325620831273860806354122009
    Q = 943816463169388288704515060744785161198300739393
    G = 126944238193304464700744888407728270206053067988260399946481804644613572277041077516125903245683829047907579525852942251868830032846850704179472361951460026689672246139449336619843792361632790302009044437663244220625821252440684387557041774419465537875472548752000651065699702208640886979583735632073464722038
    d = 428671931574830922674102537016825886480531392857
    Beta = 103718230444085070900375093426337071524067234088045441286613540625780235831262473919360731456240645209246348774481759747729830084253319844435044944026008723657264339366615645385052523819693193728893877312742284035288701705610745863541101900237298330484983751005369934456334094957302238057653529674343701113550
    check = 0
    if (P-1)%Q == 0:
        check += 1
    if pow(G,Q,P) == 1:
        check += 1
    if pow(G,d,P) == Beta:
        check +=1
    if check == 3:
        print("DSA Parameters are looking good, all {} checks passed!".format(check))
    else:
        print("DSA Parameters are NOT looking so good! {} of 3 passed".format(check))
    # How to sign using openssl
    # echo "andy is great" >thingstosign.txt
    # openssl dgst -sha256 -sign dsa_priv.pem thingstosign.txt>signature.bin
    # openssl dsa -in dsa_priv.pem -pubout -out dsa_pub.pem
    # openssl asn1parse -in signature.bin -inform der
    r = int('68296E4947C3377574B2695D91877603A06C6FC6', 16)
    s = int('52762DCA633EFB7F18D785043D3C7AB5A97C3CD8', 16)
    # note that \n is included because the file was populated from echo which included the new line char.
    H = hashlib.sha256('andy is great\n'.encode()).hexdigest()
    z = int(H[:40], 16)
    print("r = ", r)
    print("s = ", s)
    print("z = ", z)
    # we can compute KE = (s_inverse * (z + d*r)) (mod q)
    s_inv = inverse(s,Q)
    print("confirm sinv*s%q = 1", s_inv*s%Q == 1)
    KE = (s_inv *(z + d*r))%Q
    print("KE = ", KE)
    if r == pow(G, KE, P)%Q:
        print("Cracked Bob's ephemeral key")
    # openssl dgst -sha256 -verify dsa_pub.pem -signature signature.bin thingstosign.txt
    # Verified OK
    u1 = (s_inv*z)%Q
    u2 = (s_inv*r)%Q
    v = ((pow(G,u1,P)*pow(Beta,u2,P))%P)%Q
    print("v = ", v)
    if v == r:
        print("SIGNATURE IS VALID!")

################################################################################################################################
# Name:         validate_ECDSA()
# Description:  performs test on DSAParameters
# Author:   
# 
# ###############################################################################################################################
def ECDSA_example():
    p = 8948962207650232551656602815159153422162609644098354511344597187200057010413552439917934304191956942765446530386427345937963894309923928536070534607816947
    a = 8948962207650232551656602815159153422162609644098354511344597187200057010413552439917934304191956942765446530386427345937963894309923928536070534607816944
    b = 6532815740455945129522030162820444801309011444717674409730083343052139800841847092116476221316466234404847931899409316558007222582458822004777353814164030
    A = (5240454105373391383446315535930423532243726242869439206480578543706358506399554673205583372921814351137736817888782671966171301927338369930113338349467098, 4783098043208509222858478731459039446855297686825168822962919559100076900387655035060042118755576220187973470126780576052258118403094460341772613532037938)
    q = 8948962207650232551656602815159153422162609644098354511344597187200057010413418528378981730643524959857451398370029280583094215613882043973354392115544169
    
    H = hashlib.sha256('andy is great\n'.encode()).hexdigest()
    z = int(H[:40], 16)

    # - ECDSA starts here #
    print("\n Alice:")
    # Generate private key d and public key(p,a,b,q,A,B)
    d = getRandomRange(1, q-1)
    while GCD(d, q-1) != 1:
         d = getRandomRange(1, q-1)
    B = tuple([d*x for x in A])
    print("public key \n",(p,a,b,q,A,B) )

    # Compute the Signature s
    KE = getRandomRange(1, q-1)
    R = tuple([KE*x for x in A])
    r = R[0]%q
    KE_inv = inverse(KE,q)
    s = (KE_inv*(z + d*r))%q

    #Verify the signature
    s_inv = inverse(s,q)
    w = s_inv % q
    u1 = (w*z)%q
    u2 = (w*r)%q
    P  = ((u1*A[0] + u2*B[0])%q, (u1*A[1]+u2*B[1])%q)
    x  = P[0]
    if x == r:
        print("You got it man!")
    print("x = ", x)
    print("r = ", r)
               
#####################################################################################################################################################
# Name:         multiple
# Description:  recursive multiply large numbers by repeated addition
# Usage:        multiply(int,int)
# 
# 
# ##################################################################################################################################################3    
def multiply(x,y):
    if  y == 0 :
        return 0
    elif y < 0:
        return -(x - multiply(x,y+1))
    else:
        return x + multiply(x,y-1)
#####################################################################################################################
# Name:        ECDHEKey()
# Description: Goes through the steps of Alice and Bob setting their public and private key and setting up a shared secret
# Usage:       
# Author:
# Date: 
# Notes: to generate parameters do the following
# 
######################################################################################################################
def ECDHEKey():
    #ALICE hat
    prime = 8948962207650232551656602815159153422162609644098354511344597187200057010413552439917934304191956942765446530386427345937963894309923928536070534607816947
    Ac =  8948962207650232551656602815159153422162609644098354511344597187200057010413552439917934304191956942765446530386427345937963894309923928536070534607816944
    Bc =  6532815740455945129522030162820444801309011444717674409730083343052139800841847092116476221316466234404847931899409316558007222582458822004777353814164030
    G =  (5240454105373391383446315535930423532243726242869439206480578543706358506399554673205583372921814351137736817888782671966171301927338369930113338349467098, 4783098043208509222858478731459039446855297686825168822962919559100076900387655035060042118755576220187973470126780576052258118403094460341772613532037938)
    order = 8948962207650232551656602815159153422162609644098354511344597187200057010413418528378981730643524959857451398370029280583094215613882043973354392115544169
    print("\n Alice:")
    a = getRandomRange(2, order-1)
    while GCD(a, order) != 1:
         a = getRandomRange(2, order-1)
    print(" Alice's private key a\n", a)
    
    # #calculate aP mod(prime)
    A = (a*G[0]%prime, a*G[1]%prime)
    print(" Alice's public key A\n", A)

    # #BOB hat
    print("\n Bob:")
    b = getRandomRange(2, order)
    while GCD(b, order-1) != 1:
         b = getRandomRange(2, order-1)
    print(" Bob's private key b\n", b)
    # #calculate bP mod(p)
    B = (b*G[0]%prime, b*G[1]%prime)
    print(" Bob's public key B\n", B)
    
    #Bob computes the shared secred which is the x value of the point aB
    bA = (b*A[0]%prime, b*A[1]%prime)
    print("\n Bob's calculated Shared Secret baP[0] \n", bA[0]) 
    
    #Alice computes his shared secred bA
    aB = (a*B[0]%prime, a*B[1]%prime)
    print(" Alice's calculated Shared Secret abP[0] \n", aB[0])
    if aB[0] == bA[0]:
        print("\n YES! Bob and Alice shared a secret") 
        return aB 
#######################################################################################
# Name: gen_ECC_key(curve)
#
#
#
####################################################################################### 
def gen_ECC_key_P256(filename):
    key = ECC.generate(curve='P-256')
    f = open(filename,'wt')
    f.write(key.export_key(format='PEM'))
    f.close()
    return key

#######################################################################################
# Name: get_ECC_public(filename)
#
#
#
####################################################################################### 
def get_ECC_public_key_P256(filename):
    f = open(filename,'rt')
    key = ECC.import_key(f.read())
    return key.public_key()

#######################################################################################
# Name: get_ECC_shared_secret
# P-256 from the Standard Curve Database 
# y*y = x*x*x + ax + b
# p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
# a = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
# b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
# G = (0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)
# n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
# h = 0x1
####################################################################################### 
def get_ECC_shared_secret(publickey):
    return 0
#######################################################################################
# Name: encrypt_AES_GCM
#
#
#
#######################################################################################    
def encrypt_AES_GCM(msg, secretKey):
  aesCipher = AES.new(secretKey, AES.MODE_GCM)
  ct, authTag = aesCipher.encrypt_and_digest(msg)
  ct = binascii.hexlify(ct)
  ct = ct.decode('utf-8')
  authTag = binascii.hexlify(authTag)
  authTag = authTag.decode('utf-8')
  noncea = binascii.hexlify(aesCipher.nonce)
  nonce = noncea.decode('utf-8')
  ciphertext = json.dumps({'nonce': nonce, 'ciphertext': ct, 'tag': authTag})
  return ciphertext
#######################################################################################
# Name: decrypt_AES_GCM
#
#
#
#######################################################################################    
def decrypt_AES_GCM(encryptedMsg, secretKey):
  b64 = json.loads(encryptedMsg)
  nonce = str(b64['nonce'])
  nonce = nonce.encode()
  nonce = binascii.unhexlify(nonce)
  ct = str(b64['ciphertext'])
  ct = ct.encode()
  ct = binascii.unhexlify(ct)
  authTag = str(b64['tag'])
  authTag = authTag.encode()
  authTag = binascii.unhexlify(authTag)
  aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)
  #nonce = binascii.b64encode(aesCipher.nonce).decode('utf-8')
  nonce = binascii.b2a_base64(aesCipher.nonce)
  plaintext = aesCipher.decrypt_and_verify(ct, authTag)
  return plaintext


#########################################################################################
# Name:        gen_nonce()
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def AES_GCM_encrypt(data, key):
    header = b"header"
    data = data.encode()
    cipher = AES.new(key, AES.MODE_GCM)
    cipher.update(header)
    ciphertext, tag = cipher.encrypt_and_digest(data)
    json_k = [ 'nonce', 'header', 'ciphertext', 'tag' ]
    json_v = [ b64encode(x).decode('utf-8') for x in (cipher.nonce, header, ciphertext, tag) ]
    result = json.dumps(dict(zip(json_k, json_v)))
    return result
#########################################################################################
# Name:        gen_nonce()
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def AES_GCM_decrypt(ct_json, key):
    try:
        b64 = json.loads(ct_json)
        json_k = [ 'nonce', 'header', 'ciphertext', 'tag' ]
        jv = {k:b64decode(b64[k]) for k in json_k}
        cipher = AES.new(key, AES.MODE_GCM, nonce=jv['nonce'])
        cipher.update(jv['header'])
        plaintext = cipher.decrypt_and_verify(jv['ciphertext'], jv['tag'])
        # print("The message was: " + plaintext.decode('utf-8'))
        return plaintext.decode('utf-8')
    except (ValueError, KeyError):
        print("Incorrect decryption")
#########################################################################################
# Name:        gen_nonce()
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def gen_nonce(bts):
    key = secrets.token_urlsafe(bts)
    tmpkey = hashlib.sha256(key.encode('utf-8'))
    return int(tmpkey.hexdigest(), 16)
#########################################################################################
# Name: 
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def gen_key(bts=256):
    key = secrets.token_urlsafe(bts)
    tmpkey = hashlib.sha256(key.encode('utf-8'))
    return tmpkey.digest(), tmpkey.hexdigest()
#########################################################################################
# Name:         gen_symmetric_keys()
# Description:  Generates 4 symmetric keys for a TLS session. This includes 1 encrytion and
#               and 1 signing key set for message sent by the client and 1 encrytion and 1 
#               signing key set for messages sent from the server.
# Usage:        
# Author:       Rico Leone
# Date: 
#########################################################################################
def gen_symmetric_keys(master_secret):
    def XOR_BA(a, b):
        return bytes([x^y for x,y in zip(a, cycle(b))])
    key = XOR_BA(master_secret, master_secret[::-1])
    key1 = hashlib.sha256(key[:int(len(key)/2)])
    key2 = hashlib.sha256(key[int(len(key)/2):])
    return key1.digest(),key2.digest()

########################################################################################
# Name:         printfw()
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def printfw(msg, lj= '    ', w=100):
    to_print = ""
    if type(msg) != type("string"):
        to_print = str(msg)
    to_print = msg 
    print(textwrap.fill(to_print, initial_indent=lj, replace_whitespace=False, drop_whitespace=True, subsequent_indent=lj, width=w))
########################################################################################
# Name:         wait_or_quit
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def wait_or_quit(msg=""):
    if msg == "any":
        exit(0)
    print_this = "    Hit Enter for " + msg + " or 'q' to quit:"
    what = input(print_this)
    if what == 'q':
        exit(0)
def pnl():
    print("\n")
########################################################################################
# Name:         colorTest()
# Description:
# Usage: 
# Author: Rico Leone
# Date: 
#########################################################################################
def colorTest():
    class ANSI():
        def background(code):
            return "\33[{code}m".format(code=code)
    
        def style_text(code):
            return "\33[{code}m".format(code=code)
    
        def color_text(code):
            return "\33[{code}m".format(code=code)
    
    
    example_ansi = ANSI.background(
        97) + ANSI.color_text(35) + ANSI.style_text(4) + " TESTE ANSI ESCAPE CODE"
    print(example_ansi)
#######################################################################################
# Name: Main
#
#
#
#######################################################################################
def TLS_Handshake():
    # Confidentiality, Integrrity, Authentication - CIA of security
    # Integrity:
    # Hashing - prevent man-in-the-middle from sending a spoofed hash - use a M.A.C - both parties establish a secret key,
    # the sender hashes the message with the secret key. The message and the digest is sent across the wire. The receiver uses
    # the key to generate his own digest from the message and compares with the received digest. So only the holder of the secret
    # could have sent the message. This is Hash based Message Authentication Code HMAC (RFC 2104)
    #1) Elliptic Curve Diffie-Hellman exchange to establish a shared secret.  Use a NIST approved curve. (Module 5)
    # use secp521r1
    # ECDH_sharded_secret = ECDHEKey()
    #2) For each chunk of public information sent generate an RSA Digital Signature. (Module 6)
    #3) Validate the RSA digital signature of the packets you receive. (Module 6)
    #4) Once you have a shared key encrypt a message using AES in GCM mode (not in our notes but not too different). (Module 3)
    
    # Goal is to Create and Send a symmetric Session Key and send encrypted data using that key
    # Alice is Client, and Bob is server
    print("\n\nStep 00:  Bob generates a certificate and includes his pulic keys, this is done in advance, so he can communicate securely with all his friends\n\n")
    # openssl ecparam -name secp521r1 -out secp521r1.pem -param_enc explicit
    # openssl ecparam -in secp521tr1.pem -text -noout > parameters
    # mv parameters parameters_EC
    # run param_readerEC()
    # edit by hand to get in json format 
    Bobs_Cert = {}
    f = open("parameters_secp521r1.json", 'r')
    json_file = f.read().strip()
    Bobs_Cert = json.loads(json_file)
    Bobs_Cert['Gener'] = tuple(Bobs_Cert['Gener'])
    prime = Bobs_Cert['Prime']
    A = Bobs_Cert['A']
    B = Bobs_Cert['B']
    G = Bobs_Cert['Gener']
    order = Bobs_Cert['Order']
    # Bob generates his
    Bobs_prvt_ECC_key = getRandomRange(2, order)
    while GCD(Bobs_prvt_ECC_key, order-1) != 1:
         Bobs_prvt_ECC_key = getRandomRange(2, order-1)
    
    # #calculate bP mod(p), Bob's public key is the x value, not both points
    Bobs_pblc_ECC_key = (Bobs_prvt_ECC_key*G[0]%prime, Bobs_prvt_ECC_key*G[1]%prime)
    # print(" Bob's public key B\n", Bobs_pblc_ECC_key[0])
    Bobs_Cert.update({'pub_key': Bobs_pblc_ECC_key[0]})
    print(" Bobs Cert:\n")
    print(Bobs_Cert)
    print("\n\n Bob's private key b:\n", Bobs_prvt_ECC_key)

    # TO DO - Bob needs to sign Key
    
    print("\n\n Step 01:  Alice sends Bob a random number 32 bytes/256 bits (clear text) indicate she wants to communicate with Bob\n\n")
    Alices_nonce = gen_nonce(32)
    print(" Alice's nonce:\n", Alices_nonce)
    Alices_nonce_Bobs_copy = Alices_nonce

    print(" Step 02:  Bob replies with his own random number (clear text), indicating he is interested in communicating with Alice\n\b")
    Bobs_nonce = gen_nonce(32)
    print(" Bob's nonce:\n", Bobs_nonce)
    Bobs_nonce_Alices_copy = Bobs_nonce

    # ----------- Both Bob and Alice have the 2 random numbers --------------------#

    print("\n\n Step 03:  Bob sends Alice the certficate, which consists of the ECDH parameters and Bob's public key")
    Bobs_Cert_Alices_copy = Bobs_Cert

    # TO DO - Alice needs to validate the signature on the CERT, using Bob's public key

    print(" Alices copy of Bobs Cert:\n", Bobs_Cert_Alices_copy)

    print("\n\n Step 04:  Alice genates the premaster secret from Bob'b public key and sends Bob her public key")
    Alices_prvt_ECC_key = getRandomRange(2, order-1)
    while GCD(Alices_prvt_ECC_key, order) != 1:
         Alices_prvt_ECC_key = getRandomRange(2, order-1)
    print(" Alice's private key a\n", Alices_prvt_ECC_key)

    # #calculate aP mod(p), Alice's public key is the x value, not both points
    Alices_pblc_ECC_key     = Alices_prvt_ECC_key*G[0]%prime
    Alices_premaster_secret = (Alices_prvt_ECC_key*Bobs_Cert['pub_key'])%prime
    print("\n Alice's calculated Shared Secret \n", Alices_premaster_secret)
    Alices_pblc_ECC_key_Bobs_copy = Alices_pblc_ECC_key
    
    print("\n\n Step 05:  Bob generates the premaster secret from Alice's public key")
    Bobs_premaster_secret = (Bobs_prvt_ECC_key*Alices_pblc_ECC_key_Bobs_copy)%prime
    print("\n Bob's calculated Shared Secret \n", Bobs_premaster_secret)
    if Bobs_premaster_secret == Alices_premaster_secret:
        print(" Premaster secrets match")
    else:
        (" ERROR: Bob and Alice's premaster secrets are different")
    print("""\n\n Step 06:  Both Bob and Alice generate the same master secret from the Premaster secret, the phrase 'master secret' 
    and the two random number that were previously exchanged. These values are hashed to make the Master Secret\n""")
    Alices_master_secret = long_to_bytes(Alices_premaster_secret) + b"master secret" + long_to_bytes(Alices_nonce) + long_to_bytes(Bobs_nonce_Alices_copy)
    Bobs_master_secret = long_to_bytes(Bobs_premaster_secret) + b"master secret" + long_to_bytes(Alices_nonce) + long_to_bytes(Bobs_nonce_Alices_copy)
    print(" Alices master secret: \n", Alices_master_secret)
    print(" Bobs master secret: \n", Bobs_master_secret)
    if Bobs_master_secret == Alices_master_secret:
        print("\n Master secrets match!")
    else:
        (" ERROR: Bob and Alice's Master secrets are different")
    print("\n Step 07:  Bob and Alice generate the Server Encryption and HMAC key pair, and the Client Encryption and HMAC key pair using the Master Secret")
    #           "key expansion" and the two random numbers. This uses a Pseudo Random Function to generate a digest with the number of bits needed for the keys.
    
    # - TO DO - write function to convert the master secrtet to 4 symmetric keys ( ) 
    client_sig_key_pair, client_sig_public_key = gen_RSA_sign_keys()
    server_sig_key_pair, server_sig_public_key = gen_RSA_sign_keys()
    print("Client signature key pair: \n", client_sig_key_pair)
    print("Server signature key pair: \n", server_sig_key_pair)
    print("Client signature key pair: \n", client_sig_public_key)
    print("Server signature key pair: \n", server_sig_public_key)
    server_encryption_key, hexkey = gen_key()
    client_encryption_key, hexkey = gen_key()

    print("Client encryption key: \n", client_encryption_key)
    print("Server encryption key: \n", server_encryption_key)

    print("\n\n Step 08:  Bob and Alice must confirm they have the Client and Server Key pairs by sending the ecnrypted verification")
    # Alice sends - Hash the Master Secret + "client finish" + hanshake hash
    # Bob replies with Hash of the Master Secret + "server finish"
    

    print("\n\nStep 09:  Alice sends a message to Bob using Client key pair to encrypt and sign")
    msg_to_Bob  = input("Write a message for Alice to send Bob:")
    ct  = AES_GCM_encrypt(msg_to_Bob, client_encryption_key)
    sig = RSA_sign(msg_to_Bob, client_sig_key_pair)
    print("\n The ciphertext sent to Bob: \n", ct)
    print("\n The signature sent to Bob: \n", sig)

    print("\n\n Step 10:  Bob verifies and decrypts Alice's message using the Client key pair")
    pt = AES_GCM_decrypt(ct, client_encryption_key)
    print(" Plaintext after decryption: \n", pt)
    RSA_verify(pt, sig, client_sig_public_key)

    print("\n\nStep 11:  Bob sends a reply to Aice using Server key pair to encrypt and sign")
    msg_to_Alice  = input("Write a reply from Bob to Alice:")
    ct  = AES_GCM_encrypt(msg_to_Alice, server_encryption_key)
    sig = RSA_sign(msg_to_Alice, server_sig_key_pair)
    print("\n The ciphertext sent to Alice: \n", ct)
    print("\n The signature sent to Alice: \n", sig)

    print("\n\n Step 10:  Alice verifies and decrypts Bob's message using the Server key pair")
    pt = AES_GCM_decrypt(ct, server_encryption_key)
    print(" Plaintext after decryption: \n", pt)
    RSA_verify(pt, sig, server_sig_public_key)



    
#######################################################################################
# Name: Main
#
#
#
#######################################################################################
def main():
    TEST = True
    if TEST:
        # Check Izzy's public key
        # p = 10675012488470385335680553059341350948539407125891252084806853996618906109827792187832140879977301818484992710410313204152292686706349267855279600518714787
        # g = 2
        # A = 4778933914150623341009953909877531450501667810825151980651468638636019704523535101088742430186729047734730486633516304519334304735838878415297458228065201
        # b, B = DHgenkeys(g, p)
        # print("B=", B)
        # print("Izzy's secret is \n", DHgensecret(A, b, p))
        # DHKEexample()
        # file = open("dh1024.pem")
        # raw = file.read().strip()
        # raw = base64.standard_b64decode(raw)
        # print(raw)
        # print(len(raw))
        # data = raw[6:(6 + 129)]d
        # print("data = \n", data)
        # p = bytes_to_long(data)
        # print(data.hex())
        # print(p)
        # Kinv()
        # p = bytes.fromhex("E912ECF78A51FC5BBFA26A00E07A0CEC5ECEB897891643DD7DDD8056A51C71124258D52DAEF464B929F6397101F00C67CFC09B3D068B522E1C8B566431936C3A606A47928582F0D8D6B23F9019FF06A900CD5AD97E02CD3DEAA0495C968A2345858C6556623A61124C711DC0708999C08D5A349592F37DFE07A49C0D82241403")
        # p = int(p.hex(),16)
        # print("p = \n", p)
        # g = 2
        # message ="The Raiders really suck! The Raiders really suck! The Raiders really suck! The Raiders really suck! The Raiders really suck!"
        # print("message lenght = ", len(message))
        # elgamalencryptionTest(p, g, message)
        # elgamalattack()
        # RSA_encrypt_decrypt()
        # print(add_points(1,1,0,1,101,-1,1))
        # param_readerEC()
        # Param_readerDSA_private()
        # validate_DSAParams()
        # RSAexample()
        # ECDSA_example()
        # publicECCkey = get_or_create_public_key("sect571r1.pem")
        # filename="BobsprivateECC.pem"
        # privatekey = gen_ECC_key_P256(filename)
        # print(privatekey)
        # pubkey = get_ECC_public_key_P256(filename)
        # print(pubkey)
        colorTest()


    else:    
        TLS_Handshake()
    
if __name__ == "__main__":
    main()